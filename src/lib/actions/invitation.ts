'use server';

import { createClient } from '@/lib/supabase/server';
import { createClient as createAdminClient } from '@supabase/supabase-js';
import { getUserOrganization } from '@/lib/actions/organization';

function getAdminClient() {
  return createAdminClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
}

export type OrgRole = 'owner' | 'admin' | 'member' | 'viewer';

export interface Invitation {
  id: string;
  organization_id: string;
  invited_by: string;
  email: string;
  role: OrgRole;
  token: string;
  accepted_at: string | null;
  expires_at: string;
  created_at: string;
}

// ---------------------------------------------------------------------------
// inviteOrgMember
// ---------------------------------------------------------------------------

export async function inviteOrgMember(
  email: string,
  role: OrgRole
): Promise<{ invitation: Invitation | null; error: string | null }> {
  const supabase = await createClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) return { invitation: null, error: 'Not authenticated' };

  const membership = await getUserOrganization();
  if (!membership) return { invitation: null, error: 'No organization found' };
  if (!['owner', 'admin'].includes(membership.role)) {
    return { invitation: null, error: 'Only owners and admins can invite members' };
  }

  // Enforce role hierarchy: a caller may only assign roles strictly below
  // their own. Owners cannot invite other owners; admins cannot invite
  // admins or owners. Ownership transfer requires a dedicated flow.
  const ROLE_RANK: Record<OrgRole, number> = {
    owner: 3,
    admin: 2,
    member: 1,
    viewer: 0,
  };
  if (ROLE_RANK[role] >= ROLE_RANK[membership.role]) {
    return {
      invitation: null,
      error: `As an ${membership.role} you cannot invite someone with the '${role}' role`,
    };
  }

  // Prevent inviting someone who is already a member.
  // Uses a SECURITY DEFINER RPC because users table RLS prevents admins
  // from querying other users' email addresses directly.
  const { data: isMember, error: checkError } = await supabase.rpc(
    'check_org_member_by_email',
    { p_org_id: membership.organization.id, p_email: email }
  );
  if (checkError) return { invitation: null, error: checkError.message };
  if (isMember) {
    return { invitation: null, error: 'This user is already a member of your organization' };
  }

  // Cancel any existing pending invitation for the same email in this org
  await supabase
    .from('invitations')
    .delete()
    .eq('organization_id', membership.organization.id)
    .eq('email', email)
    .is('accepted_at', null);

  // Create invitation (token auto-generated by DB)
  const { data: invitation, error: insertError } = await supabase
    .from('invitations')
    .insert({
      organization_id: membership.organization.id,
      invited_by: user.id,
      email,
      role,
    })
    .select()
    .single();

  if (insertError || !invitation) {
    return { invitation: null, error: insertError?.message ?? 'Failed to create invitation' };
  }

  // Send invitation email via Supabase Auth admin (uses configured SMTP)
  const appUrl = process.env.NEXT_PUBLIC_APP_URL ?? 'http://localhost:3000';
  const inviteUrl = `${appUrl}/invitations/accept?token=${invitation.token}`;

  // Route through /auth/callback so the session is established before the
  // invite accept page loads. This mirrors how signInWithGoogle / magic link work.
  const callbackUrl = `${appUrl}/auth/callback?next=${encodeURIComponent(`/invitations/accept?token=${invitation.token}`)}`;

  const adminSupabase = getAdminClient();
  adminSupabase.auth.admin
    .inviteUserByEmail(email, { redirectTo: callbackUrl })
    .catch(() => {
      // Email delivery failure should not block the invitation creation
    });

  return { invitation: invitation as Invitation, error: null };
}

// ---------------------------------------------------------------------------
// getPendingInvitations
// ---------------------------------------------------------------------------

export async function getPendingInvitations(): Promise<{
  invitations: Invitation[];
  error: string | null;
}> {
  const supabase = await createClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) return { invitations: [], error: 'Not authenticated' };

  const membership = await getUserOrganization();
  if (!membership) return { invitations: [], error: 'No organization found' };
  if (!['owner', 'admin'].includes(membership.role)) {
    return { invitations: [], error: 'Permission denied' };
  }

  const { data, error } = await supabase
    .from('invitations')
    .select('*')
    .eq('organization_id', membership.organization.id)
    .is('accepted_at', null)
    .gt('expires_at', new Date().toISOString())
    .order('created_at', { ascending: false });

  if (error) return { invitations: [], error: error.message };
  return { invitations: (data ?? []) as Invitation[], error: null };
}

// ---------------------------------------------------------------------------
// cancelInvitation
// ---------------------------------------------------------------------------

export async function cancelInvitation(
  invitationId: string
): Promise<{ error: string | null }> {
  const supabase = await createClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) return { error: 'Not authenticated' };

  const membership = await getUserOrganization();
  if (!membership) return { error: 'No organization found' };
  if (!['owner', 'admin'].includes(membership.role)) {
    return { error: 'Only owners and admins can cancel invitations' };
  }

  const { error } = await supabase
    .from('invitations')
    .delete()
    .eq('id', invitationId)
    .eq('organization_id', membership.organization.id)
    .is('accepted_at', null);

  return { error: error?.message ?? null };
}

// ---------------------------------------------------------------------------
// getInvitationByToken  (for the accept page — no auth required)
// ---------------------------------------------------------------------------

export interface InvitationPreview {
  email: string;
  role: OrgRole;
  org_name: string;
  expires_at: string;
}

export async function getInvitationByToken(
  token: string
): Promise<{ preview: InvitationPreview | null; error: string | null }> {
  const supabase = await createClient();

  // Uses a SECURITY DEFINER RPC — the broad invitations_select_by_token RLS
  // policy has been removed; access is gated by knowing the exact token.
  const { data, error } = await supabase.rpc('get_invitation_by_token', {
    p_token: token,
  });

  if (error) return { preview: null, error: error.message };
  const row = Array.isArray(data) ? data[0] : data;
  if (!row) return { preview: null, error: 'Invalid or expired invitation' };

  return {
    preview: {
      email: row.email as string,
      role: row.role as OrgRole,
      org_name: row.org_name as string,
      expires_at: row.expires_at as string,
    },
    error: null,
  };
}

// ---------------------------------------------------------------------------
// acceptInvitation  (calls the SECURITY DEFINER RPC)
// ---------------------------------------------------------------------------

export async function acceptInvitation(
  token: string
): Promise<{ organizationId: string | null; role: OrgRole | null; error: string | null }> {
  const supabase = await createClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) return { organizationId: null, role: null, error: 'Not authenticated' };

  const { data, error } = await supabase.rpc('accept_invitation', { p_token: token });

  if (error) return { organizationId: null, role: null, error: error.message };

  const result = data as { error?: string; success?: boolean; organization_id?: string; role?: string };
  if (result.error) return { organizationId: null, role: null, error: result.error };

  return {
    organizationId: result.organization_id ?? null,
    role: (result.role as OrgRole) ?? null,
    error: null,
  };
}
