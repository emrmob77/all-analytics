'use server';

import { createClient } from '@/lib/supabase/server';
import { getUserOrganization } from '@/lib/actions/organization';

export type OrgRole = 'owner' | 'admin' | 'member' | 'viewer';

export interface Invitation {
  id: string;
  organization_id: string;
  invited_by: string;
  email: string;
  role: OrgRole;
  token: string;
  accepted_at: string | null;
  expires_at: string;
  created_at: string;
}

// ---------------------------------------------------------------------------
// inviteOrgMember
// ---------------------------------------------------------------------------

export async function inviteOrgMember(
  email: string,
  role: OrgRole
): Promise<{ invitation: Invitation | null; error: string | null }> {
  const supabase = await createClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) return { invitation: null, error: 'Not authenticated' };

  const membership = await getUserOrganization();
  if (!membership) return { invitation: null, error: 'No organization found' };
  if (!['owner', 'admin'].includes(membership.role)) {
    return { invitation: null, error: 'Only owners and admins can invite members' };
  }

  // Prevent inviting someone who is already a member
  const { data: existing } = await supabase
    .from('org_members')
    .select('user_id, users(email)')
    .eq('organization_id', membership.organization.id)
    .maybeSingle();

  // Check via users table join — simpler: check invitations + org_members by email
  const { data: existingMember } = await supabase
    .from('org_members')
    .select('id, users!inner(email)')
    .eq('organization_id', membership.organization.id)
    .eq('users.email', email)
    .maybeSingle();

  if (existingMember) {
    return { invitation: null, error: 'This user is already a member of your organization' };
  }

  // Cancel any existing pending invitation for the same email in this org
  await supabase
    .from('invitations')
    .delete()
    .eq('organization_id', membership.organization.id)
    .eq('email', email)
    .is('accepted_at', null);

  // Create invitation (token auto-generated by DB)
  const { data: invitation, error: insertError } = await supabase
    .from('invitations')
    .insert({
      organization_id: membership.organization.id,
      invited_by: user.id,
      email,
      role,
    })
    .select()
    .single();

  if (insertError || !invitation) {
    return { invitation: null, error: insertError?.message ?? 'Failed to create invitation' };
  }

  // Fire-and-forget: send invitation email via Edge Function
  const appUrl = process.env.NEXT_PUBLIC_APP_URL ?? 'http://localhost:3000';
  const inviteUrl = `${appUrl}/invitations/accept?token=${invitation.token}`;
  const inviterName =
    (user.user_metadata?.full_name as string) ??
    (user.user_metadata?.name as string) ??
    user.email ??
    'A team member';

  supabase.functions
    .invoke('send-invitation-email', {
      body: {
        to: email,
        orgName: membership.organization.name,
        inviterName,
        role,
        inviteUrl,
      },
    })
    .catch(() => {
      // Email delivery failure should not block the invitation creation
    });

  return { invitation: invitation as Invitation, error: null };
}

// ---------------------------------------------------------------------------
// getPendingInvitations
// ---------------------------------------------------------------------------

export async function getPendingInvitations(): Promise<{
  invitations: Invitation[];
  error: string | null;
}> {
  const supabase = await createClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) return { invitations: [], error: 'Not authenticated' };

  const membership = await getUserOrganization();
  if (!membership) return { invitations: [], error: 'No organization found' };
  if (!['owner', 'admin'].includes(membership.role)) {
    return { invitations: [], error: 'Permission denied' };
  }

  const { data, error } = await supabase
    .from('invitations')
    .select('*')
    .eq('organization_id', membership.organization.id)
    .is('accepted_at', null)
    .gt('expires_at', new Date().toISOString())
    .order('created_at', { ascending: false });

  if (error) return { invitations: [], error: error.message };
  return { invitations: (data ?? []) as Invitation[], error: null };
}

// ---------------------------------------------------------------------------
// cancelInvitation
// ---------------------------------------------------------------------------

export async function cancelInvitation(
  invitationId: string
): Promise<{ error: string | null }> {
  const supabase = await createClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) return { error: 'Not authenticated' };

  const membership = await getUserOrganization();
  if (!membership) return { error: 'No organization found' };
  if (!['owner', 'admin'].includes(membership.role)) {
    return { error: 'Only owners and admins can cancel invitations' };
  }

  const { error } = await supabase
    .from('invitations')
    .delete()
    .eq('id', invitationId)
    .eq('organization_id', membership.organization.id)
    .is('accepted_at', null);

  return { error: error?.message ?? null };
}

// ---------------------------------------------------------------------------
// getInvitationByToken  (for the accept page — no auth required)
// ---------------------------------------------------------------------------

export interface InvitationPreview {
  email: string;
  role: OrgRole;
  org_name: string;
  expires_at: string;
}

export async function getInvitationByToken(
  token: string
): Promise<{ preview: InvitationPreview | null; error: string | null }> {
  const supabase = await createClient();

  const { data, error } = await supabase
    .from('invitations')
    .select('email, role, expires_at, organizations(name)')
    .eq('token', token)
    .is('accepted_at', null)
    .gt('expires_at', new Date().toISOString())
    .maybeSingle();

  if (error) return { preview: null, error: error.message };
  if (!data) return { preview: null, error: 'Invalid or expired invitation' };

  return {
    preview: {
      email: data.email,
      role: data.role as OrgRole,
      org_name: (data.organizations as unknown as { name: string })?.name ?? '',
      expires_at: data.expires_at,
    },
    error: null,
  };
}

// ---------------------------------------------------------------------------
// acceptInvitation  (calls the SECURITY DEFINER RPC)
// ---------------------------------------------------------------------------

export async function acceptInvitation(
  token: string
): Promise<{ organizationId: string | null; role: OrgRole | null; error: string | null }> {
  const supabase = await createClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) return { organizationId: null, role: null, error: 'Not authenticated' };

  const { data, error } = await supabase.rpc('accept_invitation', { p_token: token });

  if (error) return { organizationId: null, role: null, error: error.message };

  const result = data as { error?: string; success?: boolean; organization_id?: string; role?: string };
  if (result.error) return { organizationId: null, role: null, error: result.error };

  return {
    organizationId: result.organization_id ?? null,
    role: (result.role as OrgRole) ?? null,
    error: null,
  };
}
